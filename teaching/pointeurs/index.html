<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta charset="utf-8">
<meta name="author" content="Boris Eng">
<meta name="description" content="Boris Eng's webpage. ATER at Université Sorbonne Paris Nord, France.">
<title>Boris Eng</title>
<link rel="canonical" href="https://engboris.fr//teaching/pointeurs/">
<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,300italic,400italic" rel="stylesheet">
<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<link href="/basic.css" rel="stylesheet">
<link href="/index.css" rel="stylesheet">
<script type="text/javascript" src="/carousel.js"></script>




<link rel="apple-touch-icon" sizes="57x57" href="/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192"  href="/android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">



<header>
  <h1>⊢ <a href="/">Boris Eng</a></h1>
  <span class="sub">ATER at Université Sorbonne Paris Nord, Villetaneuse (France)</span>
  <span class="sub" style="float: right;">[last name][first name]@hotmail.fr</span>
  <nav>
    <div id="menu">
        <a  href="/">Home</a>
        <a  href="/research/">Research</a>
        <a  href="/teaching/">Teaching</a>
        <a  href="/library/">Library</a>
        <a  href="/trivia/">Trivia</a>
        <a  href="/cv/">CV</a>
    </div>
    <div>
        
    </div>
  </nav>
</header>

<main>
  <article >
    <a href="/teaching">« Return to Teaching</a>
    
    <header>
      
      <time datetime=""></time>
      
    </header>
    <h1 id="entraînement-sur-les-pointeurs-en-c">Entraînement sur les pointeurs en C</h1>

<p>Les pointeurs permettent de gérer nous-même certaines opérations sur la mémoire et d’avoir plus de flexibilité lorsqu’on programme. Les utiliser demande une grande rigueur pour éviter de créer des problèmes de mémoire (SEGFAULT, accès non autorisé à la mémoire, accès en dehors des bornes d’un tableau etc).</p>

<h2 id="tableaux-dynamiques">Tableaux dynamiques</h2>

<p>Les tableaux en C sont statiques : on les utilise lorsqu’on traite un nombre spécifique de données dont les bornes sont connues. Avec les pointeurs, on peut simuler un tableau nous-même. Comparons les deux approches :</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="c1">
</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="c1">
</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// Approche par tableau statique
</span>
	<span class="kt">int</span> <span class="n">tab</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
	<span class="n">tab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"tab[0] = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tab</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"adresse de tab[0] = %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tab</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	
	<span class="c1">// Approche par pointeurs
</span>
	<span class="c1">// pointeur pour lequel on autorise une zone de 5 blocs d'entiers dans la mémoire
</span>
	<span class="kt">int</span><span class="o">*</span> <span class="n">tab2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
	<span class="o">*</span><span class="n">tab2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// premier élément du tableau
</span>
	<span class="o">*</span><span class="p">(</span><span class="n">tab2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// deuxième élément du tableau : celui à l'adresse de tab2 + 1 bloc
</span>
	<span class="o">*</span><span class="p">(</span><span class="n">tab2</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="o">*</span><span class="p">(</span><span class="n">tab2</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="o">*</span><span class="p">(</span><span class="n">tab2</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="o">*</span><span class="n">tab2</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"tab2[0] = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">tab2</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"adresse de tab2[0] = %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">tab2</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Ecrire les fonctions suivantes :</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">void reverse(int* tab, int taille)</code> qui inverse les éléments d’un tableau représenté par un pointeur.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">void fusion(int* tab1, int* tab2, int taille1, int taille2)</code> qui colle <code class="language-plaintext highlighter-rouge">tab2</code> à la suite de <code class="language-plaintext highlighter-rouge">tab1</code>.</p>
  </li>
</ol>

<p>Faisons une petite expérience. Imaginons que nous représentons des messages avec des chaînes de caractère de type <code class="language-plaintext highlighter-rouge">char*</code> se terminant par <code class="language-plaintext highlighter-rouge">\0</code>. On représente une boîte aux lettres par un pointeur sur des messages. On a donc ces types :</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">typedef</span> <span class="kt">char</span><span class="o">*</span> <span class="n">message</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">message</span><span class="o">*</span> <span class="n">boite</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Ecrire les fonctions suivantes :</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">int est_vide(boite b)</code> qui renvoie 1 si la boite est vide et 0 sinon.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">void ajouter_message(boite b, message m)</code> qui ajoute le message <code class="language-plaintext highlighter-rouge">m</code> à la boîte <code class="language-plaintext highlighter-rouge">b</code>.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">void lire(boite b)</code> qui affiche le premier message puis le jette.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">void jeter(boite b)</code> qui jette le premier message sans le lire.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">void lire_tout(boite b)</code> qui lit tous les messages d’une boîte en jetant les lettres à chaque fois.</p>
  </li>
</ol>

<h2 id="pointeurs-et-structures--listes-chaînées">Pointeurs et structures : listes chaînées</h2>

<p>Une liste chaînée est une liste formée de noeuds indépendants qui sont liés ensemble. On n’y accède pas par des indices mais en suivant une chaîne de pointeurs. Un avantage est que les éléments ne sont pas à la suite dans la mémoire. Il est facile de supprimer un élément ou d’en ajouter un au milieu. On va utiliser le type suivant :</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">Noeud</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">valeur</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Noeud</span><span class="o">*</span> <span class="n">suivant</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">Noeud</span> <span class="n">Noeud</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Voici un exemple de liste chaînée contenant 1, 2 et 3 à la suite.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="n">Noeud</span> <span class="n">n3</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
<span class="n">Noeud</span> <span class="n">n2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n3</span><span class="p">};</span>
<span class="n">Noeud</span> <span class="n">n1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n2</span><span class="p">};</span>
<span class="n">Noeud</span><span class="o">*</span> <span class="n">tete</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">n1</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>Ecrivez les fonctions suivantes :</p>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">void afficher(Noeud* tete)</code> qui prend la tête d’une liste chaînée et affiche tous les éléments qui la suivent.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">void ajouter_debut(Noeud* tete, Noeud* new)</code> qui ajoute un nouvel élément en tête de la liste chaînée.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">void ajouter_fin(Noeud* tete, Noeud* new)</code> qui ajoute un nouvel élément à la fin de la liste chaînée.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">void supprimer(Noeud* tete, int v)</code> qui supprime tous les éléments qui ont pour valeur <code class="language-plaintext highlighter-rouge">v</code>.</p>
  </li>
</ol>

  </article>
</main>


